PROC WZG_RAUS (INT _PRG[0],INT _PRG[1],INT _PRG[2],INT _PRG[3],INT _PRG[4])
; ARGUMENT 1: WZG ZUM AUSLAGERN ALS PRG-NUMMER 
; ARGUMENTE 2-5: WZG ZUM VERBLEIB IN DER MASCHINE ALS PRG-NUMMER
;
;
;
;
;
;
; MSG("DEFINITIONEN VON VARIABLEN")
; I. PRG-NR. IN PRG-PFAD UMWANDELN
DEF INT _PRG_NUM = 0, _STR_LENGTH
DEF STRING[255] _PRG_NAME[4]
;
; II. MIT PRG-NR PFAD SUCHEN 
DEF STRING[255] _PRG_PFAD[4]
DEF BOOL _ISFILE
;
; III. Auflistung aller WZG aus dem Magazin und/oder Bearbeitungsprogrammen.
DEF INT _INTERNE_T_NO
DEF INT _COUNTER_RAUS, _COUNTER_RAUS_MAX, _COUNTER_BLEIBT, _COUNTER_BLEIBT_MAX, _I
DEF STRING[255] _LIST_RAUS[255], _LIST_BLEIBT[255], _AKTUELLES_WZG
DEF INT _ERROR
DEF INT _XID, _YID
DEF INT _TEIL_STR, _ZEILEN_INHALT_A, _ZEILEN_INHALT_B, _PROGEND
DEF STRING[255] _ZEILEN_INHALT, _KEY_STR
;
; IV. ABGLEICHEN
DEF INT _GETT
DEF STRING[255] _PFAD_PROTOKOLL = ""/_N_WKS_DIR/_N_WZG_RAUS_WPD/_N_PROTOKOLL_MPF""
;
;
;
;
;
; I. PRG-NR. IN PRG-PFAD UMWANDELN
;
;
; MSG("PRG-NR. IN PRG-PFAD UMWANDELN")
; MSG("PRG-NR. IN STRING UMWANDELN")
FOR _PRG_NUM = 0 TO 4
  _PRG_NAME[_PRG_NUM]=<<_PRG[<<_PRG_NUM]
  _STR_LENGTH = STRLEN(_PRG_NAME[_PRG_NUM])
;  
  IF _STR_LENGTH==1 
    _PRG_NAME[_PRG_NUM]="000"<<_PRG_NAME[_PRG_NUM]""
  ENDIF
  IF _STR_LENGTH==2 
    _PRG_NAME[_PRG_NUM]="00"<<_PRG_NAME[_PRG_NUM]""
  ENDIF
  IF _STR_LENGTH==3 
    _PRG_NAME[_PRG_NUM]="0"<<_PRG_NAME[_PRG_NUM]""
  ENDIF
  IF _STR_LENGTH==4 
    _PRG_NAME[_PRG_NUM]=""<<_PRG_NAME[_PRG_NUM]""
  ENDIF
  IF _STR_LENGTH > 4
    MSG("Fehler: PRG-NR. ZU LANG ODER UNDEFINIERT")
    M0
    RET
  ENDIF
ENDFOR
;
;
;
;
;
; II. MIT PRG-NR PFAD SUCHEN 
;
;
FOR _PRG_NUM = 0 TO 4
  IF _PRG_NAME[_PRG_NUM]=="" OR _PRG_NAME[_PRG_NUM]=="0000" GOTOF NEXT_FOR_1
; Altes Prg.System
  _PRG_PFAD[_PRG_NUM]="/_N_WKS_DIR/_N_39"<<_PRG_NAME[_PRG_NUM]<<"_WPD/_N_39"<<_PRG_NAME[_PRG_NUM]<<"1_MPF"
  _ISFILE=ISFILE(_PFAD[_PRG_NUM])
  IF _ISFILE==FALSE
; Neues Prg.System
    _PRG_PFAD[_PRG_NUM]="/_N_WKS_DIR/_N_A39"<<_PRG_NAME[_PRG_NUM]<<"1_WPD/_N_A39"<<_PRG_NAME[_PRG_NUM]<<"1_MPF"
    _ISFILE=ISFILE(_PFAD[_PRG_NUM])
    IF _ISFILE==FALSE
      MSG("FEHLER: PROGRAMM "<<_PRG_NAME[_PRG_NUM]<<" NICHT IN NCK GELADEN")
      M0
      RET
    ENDIF  
  ENDIF
NEXT_FOR_1:
ENDFOR
;
; Test TEIL II.
;FOR _PRG_NUM = 1 TO 5
;  MSG(<<_PRG_PFAD[_PRG_NUM])
;  M0
;ENDFOR
;
;
;
;
;
; III. Auflistung aller WZG aus dem Magazin und/oder Bearbeitungsprogrammen.
;
;
_KEY_STR = "CS_TOOL" ; SCHLUESSELWORT; UM WERKZEUG-BEZEICHNUNG IM PRG ZU FINDEN.
;
; III.A. ENTLADE LISTE ERSTELLEN
FOR _PRG_NUM = 0 TO 4  
; ALLE WZG IM MAGAZIN AUFLISTEN
IF _PRG_NAME[0] == "" OR "0000" ; WENN ERSTER PARAMETER LEER IST, DANN LISTE ALLE WZG AUS DEM MAGAZIN AUF
  _COUNTER_BLEIBT=0
  _INTERNE_T_NO=1
  FOR _INTERNE_T_NO=1 TO 32000 ; INTERNE WZG-NUMMER
    IF ($A_TOOLMN[_INTERNE_T_NO] == 1) ; WENN "WZG IST IM MAGAZIN"
      _LIST_RAUS[_COUNTER_BLEIBT] = $TC_TP2[_INTERNE_T_NO] ; SCHREIBE WZG-BEZEICHNUNG IN VARIABLE
      _COUNTER_BLEIBT=_COUNTER_BLEIBT+1 
      _COUNTER_BLEIBT_MAX = _COUNTER_BLEIBT
    ENDIF
  ENDFOR
ENDIF 
; III.B. LISTE FUER WZG ERSTELLEN DIE IM MAG BLEIBEN
; LISTE AUSNAHME-WZG
_COUNTER_BLEIBT = 0
_LIST_BLEIBT[0] = "900000"
_LIST_BLEIBT[1] = "900001"
_LIST_BLEIBT[2] = "900002"
_LIST_BLEIBT[3] = "900003"
_LIST_BLEIBT[4] = "900004"
_LIST_BLEIBT[5] = "900005"
_LIST_BLEIBT[6] = "900006"
_LIST_BLEIBT[7] = "900007"
_LIST_BLEIBT[8] = "900008"
_LIST_BLEIBT[9] = "900009"
; WENN PRG[0] > 0 DANN LISTE DEN KERN AUF, DER AUSGELAGERT WIRD.
IF _PRG_NAME[_PRG_NUM] == "" OR "0000" ; FUER PRG 1-5
CONTINUE ; Gehe zum naechsten Bearbeitungsprogramm
ELSE
; 1. Satzweise durchs Bearbeitungsprogramm LESEN
; 2. WZG nach Schluesselwort suchen
; 3. WZG in Variable auflisten
_XID = 0 ;  AKTUELL GELESENE ZEILEN-NR.
_YID = 1 ;  ZEILENANZAHL, DIE GLEICHZEIT GELESEN WIRD.
_COUNTER_BLEIBT = 9 ; ARRAY INDEX
;
STARTREAD1:
_XID=_XID+1 
READ(_ERROR, _PRG_PFAD[_PRG_NUM], _XID, _YID, _ZEILEN_INHALT)
; TEST: Gelesene Zeile ausgeben
;MSG("LESE ZEILE #"<<_XID<<":    "<<_ZEILEN_INHALT[0]<<"")
;M0
;STRING AUSLESEN UND NACH CODE SUCHEN
_TEIL_STR = MATCH(_ZEILEN_INHALT[0], _KEY_STR)+7  
;MSG(<<_TEILSTR)
;M0
;"IN-BUILD FUNCTION" MATCH SUCHT STRING IN STRING. LIEFERT INT.
IF _TEIL_STR==6 GOTOF ENDREAD1; SATZ ENTHAELT SCHLUESSELWORT NICHT
;NACH WZG-BEZEICHNUNG SUCHEN
_ZEILEN_INHALT_A = INDEX(_ZEILEN_INHALT[0],"'"'")+1
_ZEILEN_INHALT_B = RINDEX(_ZEILEN_INHALT[0],"'"'")+1
_AKTUELLES_WZG = SUBSTR(_ZEILEN_INHALT[0],_ZEILEN_INHALT_A, _ZEILEN_INHALT_B - _ZEILEN_INHALT_A - 1) 
;
; TEST: _AKTUELLES_WZG
;MSG("TOOL NAME: "<<_AKTUELLES_WZG<<"")
;M0
;
;WZ-BEZEICHNUNG IN ARRAY SPEICHERN

IF _PRG_NUM == 0
_COUNTER_RAUS = _COUNTER_RAUS + 1
_COUNTER_RAUS_MAX = _COUNTER_RAUS
_LIST_RAUS[_COUNTER_RAUS] = _AKTUELLES_WZG
ELSE
_COUNTER_BLEIBT = _COUNTER_BLEIBT + 1
_COUNTER_BLEIBT_MAX = _COUNTER_BLEIBT
_LIST_BLEIBT[_COUNTER_BLEIBT] = _AKTUELLES_WZG
ENDIF
;RUECKSPRUNG SOLANGE KEIN M30
ENDREAD1:
_PROGEND=MATCH(_ZEILEN_INHALT[0],"M30")+1
WHILE _PROGEND==0
GOTOB STARTREAD1
ENDWHILE
ENDFOR
;
;
;
;
;
; IV. ABGLEICHEN
;
;
; Eventuell vorhandenes Protokoll loeschen
_ISFILE=ISFILE(_PFAD[_PRG_NUM])
IF _ISFILE == TRUE
  DELETE(_ERROR, _PFAD_PROTOKOLL)
ENDIF
; 1. Iterieren durch _LIST_RAUS. BIT 'U' wird gesetzt.
FOR _I=1 TO _COUNTER_RAUS_MAX
  _GETT = GETT(_LIST_RAUS[_I])
  IF (_GETT >= 1) ; Wenn Wzg im Magazin ist.
    $TC_TP8[_GETT] = $TC_TP8[_GETT] B_OR 'B10000000011' ; SETZE BIT 'U'
  ENDIF
ENDFOR
; 2. Iterieren durch _LIST_BLEIBT. Wenn Bit 'U' gesetz ist, wird er wieder entfernt.
FOR _I=1 TO _COUNTER_BLEIBT_MAX
  _GETT = GETT(_LIST_BLEIBT[_I])
  IF ($TC_TP8[_GETT] == $TC_TP8[_GETT] B_OR 'B10000000011') ; WENN BIT GESETZT IST. 
    $TC_TP8[_GETT] = $TC_TP8[_GETT] B_AND 'B1111101111111111' ; ENTFERNE BIT 'U'
  ENDIF
ENDFOR
; 3. Iterieren durch _LIST_RAUS. 
_COUNTER_RAUS = 0
; PROTOKOLL-KOPF SCHREIBEN
WRITE(_ERROR, _PFAD_PROTOKOLL, "; PROTOKOLL - WZG ZU ENTLADEN    % 39 "<<_PROG[1]<<"  ")
; Wenn Bit 'U' gesetzt ist, wird aufgezaehlt.
FOR _I=1 TO _COUNTER_RAUS_MAX
  _GETT = GETT(_LIST_RAUS[_I])
  IF (_GETT >= 1) ; Wenn Wzg im Magazin ist.
    IF ($TC_TP8[_GETT] == $TC_TP8[_GETT] B_OR 'B10000000011') ; WENN BIT GESETZT IST. 
      ; ENTFERNE 'U', WENN WZG IN DER SPINDEL IST.
      IF ($A_TOOLMN[_GETT]==9998) 
        $TC_TP8[_GETT] = $TC_TP8[_GETT] B_AND 'B1111101111111111' ; ENTFERNE BIT 'U'
        ; PROTOKOLLIERE: WIRD NICHT ENTLADEN: WZG IST IN SPINDEL.
        WRITE(_ERROR, _PFAD_PROTOKOLL, ""<<$TC_TP8[_GETT]<<" WZG IN SPINDEL - WIRD NICHT ENTLADEN!")
      ENDIF
      ; ENTFERNE 'U', WENN WZG IM WECHSELMODUS IST.
      IF ;... BIT 15? 
        $TC_TP8[_GETT] = $TC_TP8[_GETT] B_AND 'B1111101111111111' ; ENTFERNE BIT 'U'
        ; PROTOKOLLIERE: WIRD NICHT ENTLADEN: WZG IST IM WECHSELMODUS.
        WRITE(_ERROR, _PFAD_PROTOKOLL, ""<<$TC_TP8[_GETT]<<" WZG IM WECHSELMODUS - WIRD NICHT ENTLADEN!")
      ENDIF
      ; Zaehle dazu
      _COUNTER_RAUS = _COUNTER_RAUS + 1
      ; PROTOKOLLIERE WZG WIRD ENTLADEN
      WRITE(_ERROR, _PFAD_PROTOKOLL, ""<<$TC_TP8[_GETT]<<" WZG WIRD ENTLADEN!")
    ELSE
      CONTINUE
    ENDIF
  ENDIF
ENDFOR
;
;
; PROTOKOLLIERE ANZAHL DER ZU ENTLADENEN WZG
WRITE(_ERROR, _PFAD_PROTOKOLL, ""<<_COUNTER_RAUS<<" WZG WERDEN ENTLADEN.")
; TIMESTAMP
WRITE(_ERROR, _PFAD_PROTOKOLL, ""<<$A_DAY<<"."<<$A_MONTH<<"."<<$A_YEAR<<"    "<<$A_HOUR<<":"<<$A_MINUTE<<":"<<$A_SECOND<<"")
;
;
;
;
;
; PROGRAMM ENDE
M17




























;
Working on a Sinumerik 840d sl.

Hi, after hours to search the internet (and I found nothing on this...), I finally found out how to loop through an array with an unknown number of elements...  So here's the magic:

N10 DEF INT TAB[10] = (1,2,3,4,5,6,7,8,9,0)
N20 DEF INT ITERATEUR = 0
N30 WHILE (ISVAR("TAB["<<ITERATEUR<<"]"))
N40     MSG(<<TAB[ITERATEUR])
N50     M0
N60     ITERATEUR = ITERATEUR+1
N70 ENDWHILE
N80 MSG(<<ITERATEUR)
N90 M0
N100 M30


The trick is with the "ISVAR" command.  It tells you if the variable name is actually a variable...  So we check all array items until we find the first element that doesn't exists!!! :)

So there it is! Enjoy!
